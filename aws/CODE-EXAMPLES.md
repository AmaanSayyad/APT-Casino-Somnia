# Kiro AI Code Generation Examples

## Smart Contract Generated by Kiro

### UniversalGameLogger.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

contract UniversalGameLogger is Ownable {
    event GameResultLogged(
        bytes32 indexed logId,
        address indexed player,
        uint8 gameType,
        uint256 betAmount,
        uint256 payout,
        bytes32 entropyRequestId,
        uint256 timestamp
    );

    struct GameLog {
        bytes32 logId;
        address player;
        uint8 gameType;
        uint256 betAmount;
        bytes resultData;
        uint256 payout;
        bytes32 entropyRequestId;
        uint256 timestamp;
        uint256 blockNumber;
    }

    mapping(bytes32 => GameLog) public gameLogs;
    mapping(address => bytes32[]) public playerGameLogs;
    mapping(address => bool) public authorizedLoggers;
    
    uint256 public totalGamesLogged;

    constructor() Ownable(msg.sender) {}

    function logGameResult(
        uint8 gameType,
        uint256 betAmount,
        bytes memory resultData,
        uint256 payout,
        bytes32 entropyRequestId
    ) external returns (bytes32) {
        require(authorizedLoggers[msg.sender], "Not authorized");
        
        bytes32 logId = keccak256(
            abi.encodePacked(
                msg.sender,
                block.timestamp,
                block.number,
                totalGamesLogged
            )
        );

        GameLog memory newLog = GameLog({
            logId: logId,
            player: msg.sender,
            gameType: gameType,
            betAmount: betAmount,
            resultData: resultData,
            payout: payout,
            entropyRequestId: entropyRequestId,
            timestamp: block.timestamp,
            blockNumber: block.number
        });

        gameLogs[logId] = newLog;
        playerGameLogs[msg.sender].push(logId);
        totalGamesLogged++;

        emit GameResultLogged(
            logId,
            msg.sender,
            gameType,
            betAmount,
            payout,
            entropyRequestId,
            block.timestamp
        );

        return logId;
    }

    function addAuthorizedLogger(address logger) external onlyOwner {
        authorizedLoggers[logger] = true;
    }

    function removeAuthorizedLogger(address logger) external onlyOwner {
        authorizedLoggers[logger] = false;
    }

    function getPlayerHistory(address player, uint256 limit) 
        external 
        view 
        returns (bytes32[] memory) 
    {
        bytes32[] memory allLogs = playerGameLogs[player];
        uint256 length = allLogs.length > limit ? limit : allLogs.length;
        bytes32[] memory result = new bytes32[](length);
        
        for (uint256 i = 0; i < length; i++) {
            result[i] = allLogs[allLogs.length - 1 - i];
        }
        
        return result;
    }
}
```

## Service Layer Generated by Kiro

### ZetaChainGameLogger.js

```javascript
import { ethers } from 'ethers';
import { zetachainTestnetConfig } from '../config/zetachainConfig';
import UniversalGameLoggerABI from '../../artifacts/contracts/UniversalGameLogger.sol/UniversalGameLogger.json';

export class ZetaChainGameLogger {
  constructor() {
    this.provider = null;
    this.contract = null;
    this.initialized = false;
  }

  async initialize() {
    try {
      this.provider = new ethers.JsonRpcProvider(
        zetachainTestnetConfig.rpcUrls.default.http[0]
      );

      this.contract = new ethers.Contract(
        zetachainTestnetConfig.contracts.universalGameLogger,
        UniversalGameLoggerABI.abi,
        this.provider
      );

      this.initialized = true;
      console.log('‚úÖ ZetaChain Game Logger initialized');
    } catch (error) {
      console.error('‚ùå Failed to initialize ZetaChain Game Logger:', error);
      throw error;
    }
  }

  async logGameResult(gameData, signer) {
    if (!this.initialized) {
      await this.initialize();
    }

    try {
      const contractWithSigner = this.contract.connect(signer);
      
      const gameTypeMap = {
        'ROULETTE': 0,
        'MINES': 1,
        'WHEEL': 2,
        'PLINKO': 3
      };

      const tx = await contractWithSigner.logGameResult(
        gameTypeMap[gameData.gameType],
        ethers.parseEther(gameData.betAmount),
        ethers.toUtf8Bytes(JSON.stringify(gameData.result)),
        ethers.parseEther(gameData.payout),
        gameData.entropyProof?.requestId || ethers.ZeroHash
      );

      const receipt = await tx.wait();
      
      return {
        txHash: receipt.hash,
        blockNumber: receipt.blockNumber,
        explorerUrl: this.getTransactionUrl(receipt.hash)
      };
    } catch (error) {
      console.error('‚ùå Failed to log game to ZetaChain:', error);
      throw error;
    }
  }

  getTransactionUrl(txHash) {
    return `${zetachainTestnetConfig.blockExplorers.default.url}/tx/${txHash}`;
  }

  async getGameHistory(playerAddress, limit = 50) {
    if (!this.initialized) {
      await this.initialize();
    }

    try {
      const logIds = await this.contract.getPlayerHistory(playerAddress, limit);
      const logs = [];

      for (const logId of logIds) {
        const log = await this.contract.gameLogs(logId);
        logs.push({
          logId: log.logId,
          player: log.player,
          gameType: log.gameType,
          betAmount: ethers.formatEther(log.betAmount),
          payout: ethers.formatEther(log.payout),
          timestamp: Number(log.timestamp),
          blockNumber: Number(log.blockNumber)
        });
      }

      return logs;
    } catch (error) {
      console.error('‚ùå Failed to get game history:', error);
      return [];
    }
  }
}

export const zetaChainGameLogger = new ZetaChainGameLogger();
```

## API Endpoint Generated by Kiro

### /api/zetachain/log-game.js

```javascript
import { ethers } from 'ethers';
import { ZetaChainGameLogger } from '../../../services/ZetaChainGameLogger';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { gameType, playerAddress, betAmount, result, payout, entropyProof } = req.body;

    // Validate required fields
    if (!gameType || !playerAddress || !betAmount || !result || payout === undefined) {
      return res.status(400).json({ 
        error: 'Missing required fields',
        required: ['gameType', 'playerAddress', 'betAmount', 'result', 'payout']
      });
    }

    // Initialize ZetaChain logger
    const logger = new ZetaChainGameLogger();
    await logger.initialize();

    // Create signer from treasury private key
    const provider = new ethers.JsonRpcProvider(
      process.env.NEXT_PUBLIC_ZETACHAIN_RPC
    );
    const signer = new ethers.Wallet(
      process.env.ZETA_TREASURY_PRIVATE_KEY,
      provider
    );

    // Log game to ZetaChain
    const logResult = await logger.logGameResult({
      gameType,
      playerAddress,
      betAmount,
      result,
      payout,
      entropyProof
    }, signer);

    return res.status(200).json({
      success: true,
      txHash: logResult.txHash,
      blockNumber: logResult.blockNumber,
      explorerUrl: logResult.explorerUrl,
      network: 'zetachain-testnet'
    });

  } catch (error) {
    console.error('‚ùå ZetaChain logging error:', error);
    return res.status(500).json({
      success: false,
      error: error.message || 'Failed to log game to ZetaChain'
    });
  }
}
```

## UI Component Generated by Kiro

### ZetaChain Transaction Link Component

```javascript
// Added to RouletteHistory.jsx, MinesHistory.jsx, WheelHistory.jsx, PlinkoHistory.jsx

const openZetaChainExplorer = (txHash) => {
  if (txHash && txHash !== 'unknown') {
    const zetaExplorerUrl = `https://testnet.zetascan.com/tx/${txHash}`;
    window.open(zetaExplorerUrl, '_blank');
  }
};

// In table cell rendering:
{bet.zetachainTxHash && bet.zetachainTxHash !== 'pending' && (
  <Box
    onClick={() => openZetaChainExplorer(bet.zetachainTxHash)}
    sx={{
      display: 'flex',
      alignItems: 'center',
      gap: 0.5,
      cursor: 'pointer',
      padding: '2px 6px',
      borderRadius: '4px',
      backgroundColor: 'rgba(0, 255, 135, 0.1)',
      border: '1px solid rgba(0, 255, 135, 0.3)',
      transition: 'all 0.2s ease',
      '&:hover': {
        backgroundColor: 'rgba(0, 255, 135, 0.2)',
        transform: 'scale(1.05)'
      }
    }}
    title="View on ZetaChain Universal Explorer"
  >
    <FaExternalLinkAlt size={10} color="#00FF87" />
    <Typography variant="caption" sx={{ color: '#00FF87', fontSize: '0.7rem', fontWeight: 'bold' }}>
      ZetaChain
    </Typography>
  </Box>
)}
```

## Configuration Generated by Kiro

### zetachainConfig.js

```javascript
export const zetachainTestnetConfig = {
  id: 7001,
  name: 'ZetaChain Athens Testnet',
  network: 'zetachain-testnet',
  nativeCurrency: {
    name: 'ZETA',
    symbol: 'ZETA',
    decimals: 18,
  },
  rpcUrls: {
    default: {
      http: [process.env.NEXT_PUBLIC_ZETACHAIN_RPC || 'https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
    },
    public: {
      http: [process.env.NEXT_PUBLIC_ZETACHAIN_RPC || 'https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
    },
  },
  blockExplorers: {
    default: {
      name: 'ZetaScan',
      url: 'https://testnet.zetascan.com',
    },
  },
  contracts: {
    universalGameLogger: process.env.NEXT_PUBLIC_ZETACHAIN_GAME_LOGGER_ADDRESS || '0xacA996A4d49e7Ed42dA68a20600F249BE6d024A4',
  },
  testnet: true,
};

export function isZetaChainConfigured() {
  return !!(
    process.env.NEXT_PUBLIC_ZETACHAIN_RPC &&
    process.env.NEXT_PUBLIC_ZETACHAIN_GAME_LOGGER_ADDRESS &&
    process.env.ZETA_TREASURY_PRIVATE_KEY
  );
}

export function getZetaChainExplorerUrl(txHash) {
  return `${zetachainTestnetConfig.blockExplorers.default.url}/tx/${txHash}`;
}
```

## Deployment Script Generated by Kiro

### deploy-zetachain-logger.js

```javascript
const hre = require("hardhat");

async function main() {
  console.log("üöÄ Deploying UniversalGameLogger to ZetaChain Athens Testnet...");

  const [deployer] = await hre.ethers.getSigners();
  console.log("üìù Deploying with account:", deployer.address);
  console.log("üí∞ Account balance:", (await deployer.provider.getBalance(deployer.address)).toString());

  const UniversalGameLogger = await hre.ethers.getContractFactory("UniversalGameLogger");
  const logger = await UniversalGameLogger.deploy();

  await logger.waitForDeployment();
  const address = await logger.getAddress();

  console.log("‚úÖ UniversalGameLogger deployed to:", address);
  console.log("üîó Explorer:", `https://testnet.zetascan.com/address/${address}`);

  // Save deployment info
  const fs = require('fs');
  const deploymentInfo = {
    network: 'zetachain-testnet',
    contractAddress: address,
    deployer: deployer.address,
    timestamp: new Date().toISOString(),
    blockNumber: await deployer.provider.getBlockNumber()
  };

  fs.writeFileSync(
    `deployments/zetachain-universal-logger-${Date.now()}.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  console.log("üìÑ Deployment info saved");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## Parallel Logging Implementation

### Game Integration Example (Mines)

```javascript
const handleGameComplete = async (result) => {
  // Generate Pyth Entropy
  const entropyResult = await pythEntropyService.generateRandom('MINES', {
    purpose: 'mines_game_result',
    gameType: 'MINES',
  });
  
  // Log to Somnia (non-blocking)
  logGame({
    gameType: 'MINES',
    betAmount: result.betAmount.toString(),
    result: result,
    payout: result.payout.toString(),
    entropyProof: {
      requestId: entropyResult.entropyProof.requestId,
      transactionHash: entropyResult.entropyProof.transactionHash
    }
  }).then(txHash => {
    if (txHash) {
      console.log('‚úÖ Mines game logged to Somnia:', getExplorerUrl(txHash));
      setGameHistory(prev => {
        const updatedHistory = [...prev];
        if (updatedHistory.length > 0) {
          updatedHistory[0] = { ...updatedHistory[0], somniaTxHash: txHash };
        }
        return updatedHistory;
      });
    }
  }).catch(error => {
    console.warn('‚ö†Ô∏è Failed to log Mines game to Somnia:', error);
  });
  
  // Log to ZetaChain (non-blocking, parallel)
  if (zetaChainEnabled) {
    setIsZetaChainLogging(true);
    
    fetch('/api/zetachain/log-game', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        gameType: 'MINES',
        playerAddress: address,
        betAmount: result.betAmount.toString(),
        result: result,
        payout: result.payout.toString(),
        entropyProof: {
          requestId: entropyResult.entropyProof.requestId,
          transactionHash: entropyResult.entropyProof.transactionHash
        }
      })
    })
    .then(async (response) => {
      if (!response.ok) throw new Error(`Backend error: ${await response.text()}`);
      return response.json();
    })
    .then(data => {
      if (data.success && data.txHash) {
        console.log('‚úÖ Mines game logged to ZetaChain:', data.explorerUrl);
        setGameHistory(prev => {
          const updatedHistory = [...prev];
          if (updatedHistory.length > 0) {
            updatedHistory[0] = { ...updatedHistory[0], zetachainTxHash: data.txHash };
          }
          return updatedHistory;
        });
      }
      setIsZetaChainLogging(false);
    })
    .catch(error => {
      console.warn('‚ö†Ô∏è Failed to log Mines game to ZetaChain:', error);
      setIsZetaChainLogging(false);
    });
  }
};
```
